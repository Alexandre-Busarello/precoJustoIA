import { AIParams, CompanyData, StrategyAnalysis, RankBuilderResult } from './types';
import { toNumber, formatCurrency } from './base-strategy';
import { StrategyFactory } from './strategy-factory';
import { GoogleGenAI } from '@google/genai';
import { calculateOverallScore, FinancialData } from './overall-score';

export class AIStrategy {
  readonly name = 'ai';

  validateCompanyData(companyData: CompanyData, params: AIParams): boolean {
    // A estrat√©gia de IA aceita qualquer empresa que tenha dados b√°sicos
    const { financials, currentPrice } = companyData;
    return !!(
      currentPrice > 0 &&
      financials.receita && toNumber(financials.receita)! > 0
    );
  }

  runAnalysis(companyData: CompanyData, params: AIParams): StrategyAnalysis {
    // Esta estrat√©gia n√£o √© usada para an√°lise individual
    // Ela √© exclusiva para ranking
    return {
      fairValue: null,
      upside: null,
      isEligible: false,
      score: 0,
      reasoning: 'Estrat√©gia de IA dispon√≠vel apenas para ranking completo.',
      criteria: []
    };
  }

  async runRanking(companies: CompanyData[], params: AIParams): Promise<RankBuilderResult[]> {
    console.log(`üöÄ [AI-STRATEGY] Iniciando an√°lise preditiva com IA para ${companies.length} empresas`);
    console.log(`üìä [AI-STRATEGY] Par√¢metros: ${JSON.stringify(params)}`);
    
    // ETAPA 1: Sele√ß√£o inteligente com LLM baseada nos crit√©rios do usu√°rio
    console.log(`üß† [AI-STRATEGY] ETAPA 1: Sele√ß√£o inteligente com LLM`);
    const selectedCompanies = await this.selectCompaniesWithAI(companies, params);
    console.log(`‚úÖ [AI-STRATEGY] ${selectedCompanies.length} empresas selecionadas pela IA na primeira etapa`);
    
    // ETAPA 2: Executar estrat√©gias tradicionais para empresas selecionadas
    console.log(`üìà [AI-STRATEGY] ETAPA 2: Executando estrat√©gias tradicionais`);
    const companiesWithStrategies = await this.executeAllStrategies(selectedCompanies);
    console.log(`‚úÖ [AI-STRATEGY] Estrat√©gias executadas para ${companiesWithStrategies.length} empresas`);
    
    // ETAPA 3: An√°lise final com IA (todas as empresas de uma vez)
    console.log(`ü§ñ [AI-STRATEGY] ETAPA 3: An√°lise final com IA (batch processing)`);
    const finalResults = await this.analyzeBatchWithAI(companiesWithStrategies, params);
    console.log(`üéØ [AI-STRATEGY] An√°lise conclu√≠da: ${finalResults.length} resultados finais`);
    
    // Ordenar e limitar resultados finais
    const sortedResults = finalResults
      .sort((a, b) => (b.key_metrics?.compositeScore || 0) - (a.key_metrics?.compositeScore || 0))
      .slice(0, params.limit || 10);
    
    console.log(`üèÜ [AI-STRATEGY] Ranking final: ${sortedResults.length} empresas`);
    console.log(`üìã [AI-STRATEGY] Top 3: ${sortedResults.slice(0, 3).map(r => `${r.ticker} (${r.key_metrics?.compositeScore})`).join(', ')}`);
    
    return sortedResults;
  }

  // NOVA ETAPA 1: Sele√ß√£o inteligente com LLM
  private async selectCompaniesWithAI(companies: CompanyData[], params: AIParams): Promise<CompanyData[]> {
    const targetCount = (params.limit || 10) + 10;
    console.log(`üîç [AI-STRATEGY] Preparando dados de ${companies.length} empresas para sele√ß√£o IA`);
    
    // Preparar dados resumidos de todas as empresas
    const companiesData = companies.map(company => ({
      ticker: company.ticker,
      name: company.name,
      sector: company.sector || 'N√£o informado',
      currentPrice: company.currentPrice,
      marketCap: toNumber(company.financials.marketCap) || 0,
      roe: toNumber(company.financials.roe) || 0,
      pl: toNumber(company.financials.pl) || 0,
      dy: toNumber(company.financials.dy) || 0,
      liquidezCorrente: toNumber(company.financials.liquidezCorrente) || 0,
      margemLiquida: toNumber(company.financials.margemLiquida) || 0,
      crescimentoReceitas: toNumber(company.financials.crescimentoReceitas) || 0,
      dividaLiquidaPl: toNumber(company.financials.dividaLiquidaPl) || 0,
      // Adicionar dados para identificar liquidez do ticker
      companyBaseName: company.name.replace(/\s+(S\.?A\.?|SA|LTDA|ON|PN|UNT).*$/i, '').trim()
    }));

    // Construir prompt para sele√ß√£o
    const selectionPrompt = this.buildSelectionPrompt(companiesData, params, targetCount);
    
    console.log(`ü§ñ [AI-STRATEGY] Enviando ${companiesData.length} empresas para sele√ß√£o IA (target: ${targetCount})`);
    
    // Retry com verifica√ß√£o de duplicatas e orienta√ß√£o de erros
    let selectedTickers: string[] = [];
    let attempts = 0;
    const maxAttempts = 3;
    let previousErrors: string[] = [];
    
    while (attempts < maxAttempts) {
      attempts++;
      console.log(`üîÑ [AI-STRATEGY] Tentativa ${attempts}/${maxAttempts} de sele√ß√£o`);
      
      // Construir prompt com orienta√ß√µes baseadas em erros anteriores
      let currentPrompt = selectionPrompt;
      if (previousErrors.length > 0) {
        const errorGuidance = `

## ‚ö†Ô∏è CORRE√á√ïES CR√çTICAS (baseado em erros anteriores):
${previousErrors.map((error, i) => `${i + 1}. ${error}`).join('\n')}

**IMPORTANTE**: Corrija esses problemas na sua resposta!`;
        
        currentPrompt += errorGuidance;
        console.log(`üìù [AI-STRATEGY] Adicionando orienta√ß√µes de erro ao prompt (${previousErrors.length} erros anteriores)`);
      }
      
      try {
        const response = await this.callGeminiAPI(currentPrompt);
        console.log(`‚úÖ [AI-STRATEGY] Resposta da IA recebida para sele√ß√£o (${response.length} chars)`);
        
        selectedTickers = this.parseSelectionResponse(response);
        console.log(`üìã [AI-STRATEGY] Tickers selecionados: ${selectedTickers.join(', ')}`);
        
        // Verificar duplicatas
        if (this.checkForDuplicateCompanies(selectedTickers, companies)) {
          const errorMsg = `N√ÉO selecione m√∫ltiplos tickers da mesma empresa. Escolha APENAS UM ticker por empresa, preferencialmente o de maior Market Cap.`;
          previousErrors.push(errorMsg);
          console.warn(`‚ö†Ô∏è [AI-STRATEGY] ${errorMsg}`);
          continue;
        }
        
        // Verificar se temos o n√∫mero correto
        if (selectedTickers.length !== targetCount) {
          const errorMsg = `Selecione EXATAMENTE ${targetCount} tickers. Voc√™ selecionou ${selectedTickers.length}. Conte corretamente e retorne apenas ${targetCount} tickers no array JSON.`;
          previousErrors.push(errorMsg);
          console.warn(`‚ö†Ô∏è [AI-STRATEGY] ${errorMsg}`);
          continue;
        }
        
        // Verificar se todos os tickers existem na base
        const invalidTickers = selectedTickers.filter(ticker => !companies.find(c => c.ticker === ticker));
        if (invalidTickers.length > 0) {
          const errorMsg = `Tickers inv√°lidos encontrados: ${invalidTickers.join(', ')}. Use APENAS tickers da lista fornecida.`;
          previousErrors.push(errorMsg);
          console.warn(`‚ö†Ô∏è [AI-STRATEGY] ${errorMsg}`);
          continue;
        }
        
        // Sucesso!
        console.log(`üéâ [AI-STRATEGY] Sele√ß√£o bem-sucedida na tentativa ${attempts}`);
        break;
        
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error(`‚ùå [AI-STRATEGY] Erro na tentativa ${attempts}: ${errorMsg}`);
        
        // Adicionar orienta√ß√£o espec√≠fica para erros de parsing
        if (errorMsg.includes('JSON') || errorMsg.includes('parse')) {
          previousErrors.push(`Retorne APENAS um array JSON v√°lido: ["TICKER1", "TICKER2", "TICKER3"]. N√ÉO adicione texto antes ou depois do array.`);
        } else {
          previousErrors.push(`Erro t√©cnico: ${errorMsg}. Simplifique a resposta e foque apenas no array JSON solicitado.`);
        }
        
        if (attempts === maxAttempts) {
          throw new Error(`Falha ap√≥s ${maxAttempts} tentativas. √öltimos erros: ${previousErrors.join(' | ')}`);
        }
      }
    }
    
    if (selectedTickers.length === 0) {
      throw new Error('Falha em selecionar empresas ap√≥s m√∫ltiplas tentativas');
    }
    
    // Filtrar empresas selecionadas
    const selectedCompanies = companies.filter(company => 
      selectedTickers.includes(company.ticker)
    );
    
    console.log(`‚úÖ [AI-STRATEGY] ${selectedCompanies.length} empresas selecionadas pela IA`);
    return selectedCompanies;
  }

  // NOVA ETAPA 2: Executar estrat√©gias para empresas selecionadas
  private async executeAllStrategies(companies: CompanyData[]): Promise<Array<{company: CompanyData, strategies: Record<string, StrategyAnalysis>}>> {
    console.log(`‚öôÔ∏è [AI-STRATEGY] Executando 6 estrat√©gias para ${companies.length} empresas`);
    
    const results = [];
    
    for (const company of companies) {
      try {
        console.log(`üìä [AI-STRATEGY] Processando estrat√©gias para ${company.ticker}`);
        
        const strategies = {
          graham: StrategyFactory.runGrahamAnalysis(company, { marginOfSafety: 0.20 }),
          dividendYield: StrategyFactory.runDividendYieldAnalysis(company, { minYield: 0.04 }),
          lowPE: StrategyFactory.runLowPEAnalysis(company, { maxPE: 15, minROE: 0.12 }),
          magicFormula: StrategyFactory.runMagicFormulaAnalysis(company, { limit: 10 }),
          fcd: StrategyFactory.runFCDAnalysis(company, {
            growthRate: 0.025,
            discountRate: 0.10,
            yearsProjection: 5,
            minMarginOfSafety: 0.20
          }),
          gordon: StrategyFactory.runGordonAnalysis(company, {
            discountRate: 0.12,
            dividendGrowthRate: 0.05
          })
        };
        
        const eligibleCount = Object.values(strategies).filter(s => s.isEligible).length;
        console.log(`‚úÖ [AI-STRATEGY] ${company.ticker}: ${eligibleCount}/6 estrat√©gias eleg√≠veis`);
        
        results.push({ company, strategies });
        
      } catch (error) {
        console.error(`‚ùå [AI-STRATEGY] Erro ao executar estrat√©gias para ${company.ticker}:`, error);
      }
    }
    
    return results;
  }

  // NOVA ETAPA 3: An√°lise final com IA (batch processing)
  private async analyzeBatchWithAI(
    companiesWithStrategies: Array<{company: CompanyData, strategies: Record<string, StrategyAnalysis>}>, 
    params: AIParams
  ): Promise<RankBuilderResult[]> {
    console.log(`üß† [AI-STRATEGY] Preparando an√°lise batch para ${companiesWithStrategies.length} empresas`);
    
    // Construir prompt com todas as empresas
    const batchPrompt = this.buildBatchAnalysisPrompt(companiesWithStrategies, params);
    
    console.log(`üöÄ [AI-STRATEGY] Enviando an√°lise batch para IA (${batchPrompt.length} chars)`);
    
    // Retry com verifica√ß√£o de duplicatas e orienta√ß√£o de erros
    let results: RankBuilderResult[] = [];
    let attempts = 0;
    const maxAttempts = 3;
    let previousErrors: string[] = [];
    
    while (attempts < maxAttempts) {
      attempts++;
      console.log(`üîÑ [AI-STRATEGY] Tentativa ${attempts}/${maxAttempts} de an√°lise batch`);
      
      // Construir prompt com orienta√ß√µes baseadas em erros anteriores
      let currentPrompt = batchPrompt;
      if (previousErrors.length > 0) {
        const errorGuidance = `

## ‚ö†Ô∏è CORRE√á√ïES CR√çTICAS (baseado em erros anteriores):
${previousErrors.map((error, i) => `${i + 1}. ${error}`).join('\n')}

**IMPORTANTE**: Corrija esses problemas na sua resposta!`;
        
        currentPrompt += errorGuidance;
        console.log(`üìù [AI-STRATEGY] Adicionando orienta√ß√µes de erro ao prompt (${previousErrors.length} erros anteriores)`);
      }
      
      try {
        const response = await this.callGeminiAPI(currentPrompt);
        console.log(`‚úÖ [AI-STRATEGY] Resposta da an√°lise batch recebida (${response.length} chars)`);
        
        results = this.parseBatchAnalysisResponse(response, companiesWithStrategies);
        console.log(`üéØ [AI-STRATEGY] ${results.length} resultados processados da an√°lise batch`);
        
        // Verificar duplicatas nos resultados
        const tickers = results.map(r => r.ticker);
        const uniqueTickers = new Set(tickers);
        
        if (tickers.length !== uniqueTickers.size) {
          const duplicates = tickers.filter((ticker, index) => tickers.indexOf(ticker) !== index);
          const errorMsg = `N√ÉO repita tickers. Duplicatas encontradas: ${duplicates.join(', ')}. Cada ticker deve aparecer APENAS UMA VEZ.`;
          previousErrors.push(errorMsg);
          console.warn(`‚ö†Ô∏è [AI-STRATEGY] ${errorMsg}`);
          continue;
        }
        
        // Verificar se temos resultados para todas as empresas
        if (results.length !== companiesWithStrategies.length) {
          const expectedTickers = companiesWithStrategies.map(c => c.company.ticker);
          const receivedTickers = results.map(r => r.ticker);
          const missing = expectedTickers.filter(t => !receivedTickers.includes(t));
          const extra = receivedTickers.filter(t => !expectedTickers.includes(t));
          
          let errorMsg = `Inclua EXATAMENTE ${companiesWithStrategies.length} empresas no resultado.`;
          if (missing.length > 0) errorMsg += ` Faltando: ${missing.join(', ')}.`;
          if (extra.length > 0) errorMsg += ` Extras inv√°lidos: ${extra.join(', ')}.`;
          
          previousErrors.push(errorMsg);
          console.warn(`‚ö†Ô∏è [AI-STRATEGY] ${errorMsg}`);
          continue;
        }
        
        // Verificar se todos os resultados t√™m campos obrigat√≥rios
        const invalidResults = results.filter(r => !r.ticker || !r.rational || typeof r.currentPrice !== 'number');
        if (invalidResults.length > 0) {
          const errorMsg = `Todos os resultados devem ter: ticker (string), currentPrice (n√∫mero), rational (texto em portugu√™s). Resultados inv√°lidos: ${invalidResults.map(r => r.ticker || 'sem ticker').join(', ')}.`;
          previousErrors.push(errorMsg);
          console.warn(`‚ö†Ô∏è [AI-STRATEGY] ${errorMsg}`);
          continue;
        }
        
        // Sucesso!
        console.log(`üéâ [AI-STRATEGY] An√°lise batch bem-sucedida na tentativa ${attempts}`);
        break;
        
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error(`‚ùå [AI-STRATEGY] Erro na tentativa ${attempts}: ${errorMsg}`);
        
        // Adicionar orienta√ß√£o espec√≠fica para erros de parsing
        if (errorMsg.includes('JSON') || errorMsg.includes('parse')) {
          previousErrors.push(`Retorne APENAS um JSON v√°lido no formato: {"results": [{"ticker": "TICKER1", "score": 85, "fairValue": 25.50, "upside": 15.2, "confidenceLevel": 0.8, "reasoning": "texto em portugu√™s"}]}. N√ÉO adicione texto antes ou depois do JSON.`);
        } else {
          previousErrors.push(`Erro t√©cnico: ${errorMsg}. Simplifique a resposta e foque apenas no JSON solicitado.`);
        }
        
        if (attempts === maxAttempts) {
          throw new Error(`Falha ap√≥s ${maxAttempts} tentativas. √öltimos erros: ${previousErrors.join(' | ')}`);
        }
      }
    }
    
    if (results.length === 0) {
      throw new Error('Falha na an√°lise batch ap√≥s m√∫ltiplas tentativas');
    }
    
    return results;
  }


  // Construir prompt para sele√ß√£o inicial
  private buildSelectionPrompt(companiesData: any[], params: AIParams, targetCount: number): string {
    const companiesList = companiesData.map(company => 
      `${company.ticker} (${company.name}) - Setor: ${company.sector} | Pre√ßo: R$ ${company.currentPrice.toFixed(2)} | Market Cap: R$ ${(company.marketCap / 1000000000).toFixed(1)}B | ROE: ${(company.roe * 100).toFixed(1)}% | P/L: ${company.pl.toFixed(1)} | DY: ${(company.dy * 100).toFixed(1)}% | Liquidez: ${company.liquidezCorrente.toFixed(2)} | Margem: ${(company.margemLiquida * 100).toFixed(1)}%`
    ).join('\n');

    return `# SELE√á√ÉO INTELIGENTE DE EMPRESAS PARA AN√ÅLISE PREDITIVA

## OBJETIVO
Selecionar as ${targetCount} melhores empresas da B3 baseado nos crit√©rios do investidor para an√°lise preditiva detalhada.

## PERFIL DO INVESTIDOR
- **Toler√¢ncia ao Risco**: ${params.riskTolerance || 'Moderado'}
- **Horizonte de Investimento**: ${params.timeHorizon || 'Longo Prazo'}
- **Foco da An√°lise**: ${params.focus || 'Crescimento e Valor'}

## CRIT√âRIOS DE SELE√á√ÉO
Considere o perfil do investidor e selecione empresas que:

### Para Toler√¢ncia CONSERVADORA:
- ROE ‚â• 12%, Liquidez ‚â• 1.5, D√≠vida/PL ‚â§ 1.0, Margem L√≠quida ‚â• 8%
- Setores est√°veis: Utilities, Consumo B√°sico, Bancos grandes

### Para Toler√¢ncia MODERADA:
- ROE ‚â• 10%, Liquidez ‚â• 1.2, D√≠vida/PL ‚â§ 2.0, Margem L√≠quida ‚â• 5%
- Diversifica√ß√£o setorial equilibrada

### Para Toler√¢ncia AGRESSIVA:
- ROE ‚â• 8%, foco em crescimento, aceita maior volatilidade
- Setores de crescimento: Tecnologia, Sa√∫de, Consumo Discricion√°rio

### Para Foco em VALOR:
- P/L baixo (‚â§ 15), P/VP baixo, empresas subvalorizadas

### Para Foco em CRESCIMENTO:
- Crescimento de receitas positivo, margens em expans√£o, setores din√¢micos

### Para Foco em DIVIDENDOS:
- DY ‚â• 4%, hist√≥rico consistente, payout sustent√°vel

## EMPRESAS DISPON√çVEIS
${companiesList}

## CRIT√âRIOS DE DIVERSIFICA√á√ÉO
Monte um ranking DIVERSIFICADO similar √† constru√ß√£o de uma carteira de investimentos:

- **Diversifica√ß√£o Setorial**: Evite concentra√ß√£o excessiva em um setor (m√°ximo 30% em um setor)
- **Apenas 1 ticker por empresa**: 
  * Se houver m√∫ltiplos tickers da mesma empresa (ex: POMO3, POMO4 ou UNIP3, UNIP5, UNIP6), escolha apenas UM
  * Priorize o ticker com MAIOR Market Cap (maior liquidez)
  * Empresas com nomes similares podem ser da mesma companhia
- **Empresas s√≥lidas**: Priorize empresas com fundamentos consistentes e Market Cap > R$ 1B
- **Alinhamento com perfil**: Respeite rigorosamente os par√¢metros do investidor

## RESPOSTA REQUERIDA
**IMPORTANTE**: Seja DIRETO e OBJETIVO. N√ÉO repita an√°lises ou explica√ß√µes.

Retorne APENAS uma lista JSON com os tickers selecionados:
["TICKER1", "TICKER2", "TICKER3", ...]

**REGRAS CR√çTICAS**:
- Selecione exatamente ${targetCount} empresas DIVERSIFICADAS
- NUNCA repita o mesmo ticker
- NUNCA inclua m√∫ltiplos tickers da mesma empresa
- Resposta deve ser APENAS o JSON, sem explica√ß√µes adicionais`;
  }

  // Construir prompt para an√°lise batch
  private buildBatchAnalysisPrompt(
    companiesWithStrategies: Array<{company: CompanyData, strategies: Record<string, StrategyAnalysis>}>, 
    params: AIParams
  ): string {
    const companiesAnalysis = companiesWithStrategies.map(({company, strategies}) => {
      const eligibleStrategies = Object.entries(strategies)
        .filter(([, strategy]) => strategy.isEligible)
        .map(([name]) => name);
      
      const fairValues = Object.entries(strategies)
        .filter(([, strategy]) => strategy.fairValue)
        .map(([name, strategy]) => `${name}: ${formatCurrency(strategy.fairValue!)}`);

      return `## ${company.ticker} (${company.name})
**Setor**: ${company.sector || 'N/A'}
**Pre√ßo Atual**: ${formatCurrency(company.currentPrice)}
**Estrat√©gias Eleg√≠veis**: ${eligibleStrategies.join(', ') || 'Nenhuma'}
**Pre√ßos Justos**: ${fairValues.join(', ') || 'N/A'}
**Indicadores**: ROE: ${((toNumber(company.financials.roe) || 0) * 100).toFixed(1)}% | P/L: ${(toNumber(company.financials.pl) || 0).toFixed(1)} | DY: ${((toNumber(company.financials.dy) || 0) * 100).toFixed(1)}%`;
    }).join('\n\n');

    return `# AN√ÅLISE PREDITIVA BATCH - INTELIG√äNCIA ARTIFICIAL

## PERFIL DO INVESTIDOR
- **Toler√¢ncia ao Risco**: ${params.riskTolerance || 'Moderado'}
- **Horizonte**: ${params.timeHorizon || 'Longo Prazo'}
- **Foco**: ${params.focus || 'Crescimento e Valor'}

## INSTRU√á√ïES CR√çTICAS
**IDIOMA**: Responda SEMPRE em PORTUGU√äS BRASILEIRO. Todas as an√°lises, reasoning e textos devem estar em portugu√™s.

Analise TODAS as empresas abaixo simultaneamente e crie um ranking preditivo considerando:

1. **Consist√™ncia Estrat√©gica**: Quantas estrat√©gias aprovaram cada empresa
2. **Qualidade dos Fundamentos**: ROE, margens, crescimento, endividamento  
3. **Potencial de Valoriza√ß√£o**: Baseado nos pre√ßos justos calculados
4. **Adequa√ß√£o ao Perfil**: Alinhamento com toler√¢ncia ao risco e foco
5. **Contexto Setorial**: Perspectivas do setor de cada empresa

**IMPORTANTE**: Voc√™ DEVE BUSCAR informa√ß√µes atualizadas na internet sobre cada empresa antes de analisar.

## EMPRESAS PARA AN√ÅLISE
${companiesAnalysis}

## RESPOSTA REQUERIDA
**ATEN√á√ÉO**: Responda EXCLUSIVAMENTE em PORTUGU√äS BRASILEIRO.

Retorne um JSON com o ranking de TODAS as empresas analisadas:

{
  "results": [
    {
      "ticker": "TICKER1",
      "score": 85,
      "fairValue": 25.50,
      "upside": 15.2,
      "confidenceLevel": 0.8,
      "reasoning": "An√°lise detalhada da empresa em PORTUGU√äS considerando estrat√©gias, fundamentos e contexto atual. Exemplo: 'Oferece forte potencial de valoriza√ß√£o baseado no FCD, suportado por d√≠vida moderada, bom ROE e alto dividend yield.'"
    }
  ]
}

**REGRAS CR√çTICAS ANTI-LOOP**: 
- Seja DIRETO e OBJETIVO, evite repeti√ß√µes
- N√ÉO analise a mesma empresa m√∫ltiplas vezes
- N√ÉO repita explica√ß√µes ou conceitos
- Ordene por score (0-100) decrescente
- Inclua TODAS as empresas analisadas APENAS UMA VEZ
- TODO o campo "reasoning" deve estar em PORTUGU√äS BRASILEIRO
- Use termos financeiros em portugu√™s (ex: "potencial de valoriza√ß√£o", "fundamentos s√≥lidos", "perspectivas positivas")
- Resposta deve ser APENAS o JSON final, sem an√°lises intermedi√°rias`;
  }

  // Verificar duplicatas de empresas (mesmo nome base)
  private checkForDuplicateCompanies(tickers: string[], companies: CompanyData[]): boolean {
    const companyNames = new Set<string>();
    
    for (const ticker of tickers) {
      const company = companies.find(c => c.ticker === ticker);
      if (!company) continue;
      
      // Normalizar nome da empresa removendo sufixos
      const baseName = company.name
        .replace(/\s+(S\.?A\.?|SA|LTDA|ON|PN|UNT|PARTICIPACOES|PARTICIPA√á√ïES).*$/i, '')
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase();
      
      if (companyNames.has(baseName)) {
        console.warn(`üö® [AI-STRATEGY] Empresa duplicada detectada: ${company.name} (${ticker})`);
        return true;
      }
      
      companyNames.add(baseName);
    }
    
    return false;
  }

  // Parse da resposta de sele√ß√£o
  private parseSelectionResponse(response: string): string[] {
    try {
      // Tentar extrair JSON da resposta
      const jsonMatch = response.match(/\[[\s\S]*?\]/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        if (Array.isArray(parsed)) {
          return parsed.filter(ticker => typeof ticker === 'string');
        }
      }
      
      // Fallback: extrair tickers por regex
      const tickerMatches = response.match(/[A-Z]{4}[0-9]{1,2}/g);
      return tickerMatches ? [...new Set(tickerMatches)] : [];
      
    } catch (error) {
      console.error('Erro ao parsear resposta de sele√ß√£o:', error);
      return [];
    }
  }

  // Parse da resposta de an√°lise batch
  private parseBatchAnalysisResponse(
    response: string, 
    companiesWithStrategies: Array<{company: CompanyData, strategies: Record<string, StrategyAnalysis>}>
  ): RankBuilderResult[] {
    console.log(`üîç [AI-STRATEGY] Iniciando parse da resposta (${response.length} chars)`);
    
    // M√∫ltiplas estrat√©gias de parsing
    const parseStrategies = [
      // Estrat√©gia 1: JSON completo
      () => {
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('JSON n√£o encontrado');
        return JSON.parse(jsonMatch[0]);
      },
      
      // Estrat√©gia 2: Apenas array de results
      () => {
        const arrayMatch = response.match(/\[[\s\S]*\]/);
        if (!arrayMatch) throw new Error('Array n√£o encontrado');
        return { results: JSON.parse(arrayMatch[0]) };
      },
      
      // Estrat√©gia 3: Limpeza de caracteres problem√°ticos
      () => {
        let cleanResponse = response
          .replace(/```json/g, '')
          .replace(/```/g, '')
          .replace(/^\s*[\r\n]/gm, '')
          .trim();
        
        const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('JSON n√£o encontrado ap√≥s limpeza');
        return JSON.parse(jsonMatch[0]);
      },
      
      // Estrat√©gia 4: Parse linha por linha para encontrar JSON v√°lido
      () => {
        const lines = response.split('\n');
        let jsonStr = '';
        let braceCount = 0;
        let started = false;
        
        for (const line of lines) {
          if (line.includes('{') && !started) {
            started = true;
            braceCount = 0;
          }
          
          if (started) {
            jsonStr += line + '\n';
            braceCount += (line.match(/\{/g) || []).length;
            braceCount -= (line.match(/\}/g) || []).length;
            
            if (braceCount === 0 && jsonStr.trim().endsWith('}')) {
              break;
            }
          }
        }
        
        if (!jsonStr.trim()) throw new Error('JSON n√£o encontrado por parsing linha a linha');
        return JSON.parse(jsonStr.trim());
      }
    ];
    
    let parsed: any = null;
    let parseError: string = '';
    
    // Tentar cada estrat√©gia de parsing
    for (let i = 0; i < parseStrategies.length; i++) {
      try {
        console.log(`üîÑ [AI-STRATEGY] Tentativa de parse ${i + 1}/${parseStrategies.length}`);
        parsed = parseStrategies[i]();
        console.log(`‚úÖ [AI-STRATEGY] Parse bem-sucedido com estrat√©gia ${i + 1}`);
        break;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        parseError += `Estrat√©gia ${i + 1}: ${errorMsg}; `;
        console.warn(`‚ö†Ô∏è [AI-STRATEGY] Estrat√©gia ${i + 1} falhou: ${errorMsg}`);
      }
    }
    
    if (!parsed) {
      console.error(`‚ùå [AI-STRATEGY] Todas as estrat√©gias de parse falharam: ${parseError}`);
      throw new Error(`Falha no parse ap√≥s ${parseStrategies.length} tentativas: ${parseError}`);
    }
    
    const results: RankBuilderResult[] = [];
      
      if (parsed.results && Array.isArray(parsed.results)) {
        for (const result of parsed.results) {
          const companyData = companiesWithStrategies.find(c => c.company.ticker === result.ticker);
          if (companyData) {
            const eligibleStrategies = Object.values(companyData.strategies).filter(s => s.isEligible).length;
            
            results.push({
              ticker: result.ticker,
              name: companyData.company.name,
              sector: companyData.company.sector,
              currentPrice: companyData.company.currentPrice,
              fairValue: result.fairValue || null,
              upside: result.upside || null,
              marginOfSafety: null,
              rational: result.reasoning || 'An√°lise gerada por IA',
              key_metrics: {
                compositeScore: result.score || 0,
                confidenceLevel: result.confidenceLevel || 0.5,
                eligibleStrategies,
                aiScore: result.score || 0
              }
            });
          }
        }
      }
      
      return results;
      
    } catch (error) {
      console.error('Erro ao parsear resposta batch:', error);
      // Fallback: retornar resultados b√°sicos
      return companiesWithStrategies.map(({company, strategies}) => ({
        ticker: company.ticker,
        name: company.name,
        sector: company.sector,
        currentPrice: company.currentPrice,
        fairValue: null,
        upside: null,
        marginOfSafety: null,
        rational: 'Erro no processamento da IA',
        key_metrics: {
          compositeScore: 50,
          confidenceLevel: 0.3,
          eligibleStrategies: Object.values(strategies).filter(s => s.isEligible).length,
          aiScore: 50
        }
      }));
    }
  }

  // Chamada para Gemini API (reutilizada)
  private async callGeminiAPI(prompt: string, retryCount = 0): Promise<string> {
    const maxRetries = 3;
    
    // Validar se a API key do Gemini est√° configurada
    if (!process.env.GEMINI_API_KEY) {
      throw new Error('GEMINI_API_KEY n√£o configurada. Configure a vari√°vel de ambiente para usar a an√°lise de IA.');
    }

    try {
      // Configurar Gemini AI
      const ai = new GoogleGenAI({
        apiKey: process.env.GEMINI_API_KEY!,
      });

      // Configurar ferramentas (busca na web)
      const tools = [
        { urlContext: {}, googleSearch: {} },
      ];

      const config = {
        thinkingConfig: {
          thinkingBudget: 0,
        },
        tools,
      };

      const model = 'gemini-2.5-flash-lite';
      const contents = [
        {
          role: 'user',
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ];

      // Fazer chamada para Gemini API com ferramentas de busca
      const response = await ai.models.generateContentStream({
        model,
        config,
        contents,
      });

        // Coletar resposta completa com detector de loop
        let fullResponse = '';
        let loopDetectionBuffer = '';
        let loopCount = 0;
        const maxLoopDetections = 3;
        
        for await (const chunk of response) {   
          if (chunk.text) {
            console.log(chunk.text);
            fullResponse += chunk.text;
            loopDetectionBuffer += chunk.text;
            
            // Detector de loop: verifica se h√° repeti√ß√µes excessivas
            const loopPatterns = [
              /(.{50,})\1{2,}/g, // Repeti√ß√£o de texto longo
              /(Analisando|Considerando|Avaliando).{0,100}(Analisando|Considerando|Avaliando)/gi, // Palavras repetitivas
              /(\{[^}]{20,}\})\s*\1/g, // JSON repetido
            ];
            
            for (const pattern of loopPatterns) {
              if (pattern.test(loopDetectionBuffer)) {
                loopCount++;
                console.warn(`‚ö†Ô∏è [AI-STRATEGY] Loop detectado (${loopCount}/${maxLoopDetections}): ${pattern.source}`);
                
                if (loopCount >= maxLoopDetections) {
                  console.error(`üö® [AI-STRATEGY] Muitos loops detectados, interrompendo resposta`);
                  throw new Error('Loop detectado na resposta da IA - reiniciando processo');
                }
                break;
              }
            }
            
            // Limpar buffer se ficar muito grande
            if (loopDetectionBuffer.length > 2000) {
              loopDetectionBuffer = loopDetectionBuffer.slice(-1000);
            }
          }
        }

      if (!fullResponse.trim()) {
        throw new Error('Resposta vazia da API Gemini');
      }

      return fullResponse;
    } catch (error) {
      console.error(`Erro na chamada do Gemini API (tentativa ${retryCount + 1}/${maxRetries + 1}):`, error);
      
      if (retryCount < maxRetries) {
        // Aguardar um tempo antes de tentar novamente (backoff exponencial)
        const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
        console.log(`Tentando novamente em ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.callGeminiAPI(prompt, retryCount + 1);
      }
      
      throw new Error(`Falha na comunica√ß√£o com Gemini API ap√≥s ${maxRetries + 1} tentativas: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);
    }
  }

  generateRational(params: AIParams): string {
    return `**AN√ÅLISE PREDITIVA COM INTELIG√äNCIA ARTIFICIAL - PREMIUM**

**Filosofia**: Utiliza Intelig√™ncia Artificial (Gemini) para analisar e sintetizar os resultados de todas as estrat√©gias tradicionais, criando uma avalia√ß√£o preditiva abrangente.

**Metodologia Aplicada**:
‚Ä¢ **Sele√ß√£o Inteligente com IA**: Primeira chamada LLM seleciona empresas baseada no perfil do investidor
‚Ä¢ **An√°lise Multiestrategica**: Executa Graham, Dividend Yield, Low P/E, F√≥rmula M√°gica, FCD e Gordon
‚Ä¢ **Pesquisa em Tempo Real**: IA busca not√≠cias e dados atualizados na internet
‚Ä¢ **Processamento Batch**: Segunda chamada LLM analisa todas as empresas simultaneamente
‚Ä¢ **S√≠ntese Inteligente**: IA analisa consist√™ncia e converg√™ncia entre estrat√©gias
‚Ä¢ **Avalia√ß√£o Preditiva**: Considera contexto macroecon√¥mico e tend√™ncias setoriais

**Par√¢metros de An√°lise**:
‚Ä¢ **Toler√¢ncia ao Risco**: ${params.riskTolerance || 'Moderado'}
‚Ä¢ **Horizonte**: ${params.timeHorizon || 'Longo Prazo'}
‚Ä¢ **Foco**: ${params.focus || 'Crescimento e Valor'}

**Diferencial Premium**:
‚Ä¢ Sele√ß√£o inteligente baseada no perfil espec√≠fico do investidor
‚Ä¢ An√°lise de 6 estrat√©gias simultaneamente para cada empresa selecionada
‚Ä¢ Intelig√™ncia Artificial com acesso a dados da internet em tempo real
‚Ä¢ Processamento batch otimizado (mais r√°pido e eficiente)
‚Ä¢ Pesquisa autom√°tica de not√≠cias e fatos relevantes recentes
‚Ä¢ S√≠ntese preditiva considerando contexto atual do mercado
‚Ä¢ Avalia√ß√£o de riscos e oportunidades espec√≠ficas por empresa
‚Ä¢ N√≠vel de confian√ßa da an√°lise baseado em m√∫ltiplas fontes
‚Ä¢ Considera√ß√£o de fatores macroecon√¥micos e setoriais atualizados

**IMPORTANTE**: Esta an√°lise utiliza Intelig√™ncia Artificial e pode gerar resultados ligeiramente diferentes em novas execu√ß√µes devido √† natureza adaptativa do modelo.

**Ideal Para**: Investidores que buscam uma an√°lise abrangente e preditiva baseada em m√∫ltiplas metodologias.

**Resultado**: Ranking preditivo personalizado com base no seu perfil de risco e objetivos de investimento.`;
  }
}
